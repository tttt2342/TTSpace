<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p><img src="https://github.com/user-attachments/assets/5164326b-6986-426e-85a6-61d799cf2b53" alt="image">— layout: post title: Molecular Dynamics (MD) date: 2025-6-1 15:00:00+0800 description: Introduction to molecular dynamics simulation tags: physics MD simulation categories: ComputationalPhysics related_posts: false —</p> <h2 id="basic-idea">Basic Idea</h2> <p>Molecular dynamics (MD) is a computer simulation technique that allows one to predict the time evolution of a system of interacting particles (atoms, molecules, granules, etc.). First we have to specify:</p> <ul> <li>aset of <strong>initial conditions</strong> (positions &amp; velocities)</li> <li> <strong>interaction potential</strong> for deriving the forces among all the particles.</li> </ul> <p>Second, the evolution in time can be followed by solving a set of classical equations of motion for all particles in the system. Within the framework of classical mechanics, the equations are: \begin{equation} m_i\frac{d^2 \vec r_i}{dt^2}=\vec F_i \end{equation} for the \(i^{\text{th}}\) particle.</p> <p>If the particles of interest are atoms, the force acting on the \(i^{\text{th}}\) atom at a given time can be obtained from the interatomic potential \(U\) : \begin{equation} \vec F_i = -\vec \nabla_i U(\vec r_1,\vec r_2,\vec r_3,…,\vec r_{N_at}) \end{equation}</p> <h4 id="advantages-of-md">Advantages of MD</h4> <ul> <li>The only input in the model - description of interatomic interaction</li> <li>No assumptions are made about the process</li> <li>Provides a detailed molecular/atomic-level information</li> <li>The main strengths of MD is the ability to study <strong>fast non-equilibrium processes</strong> with atomic-level resolution.</li> </ul> <h4 id="limitations-of-classic-md">Limitations of Classic MD</h4> <ul> <li>Usage of classical forces - ignoring quantum mechanical laws - de Brogile wavelength \(\lambda = \frac{h}{p}\)</li> <li>Quantum effects become important when \(T\) is quite low - Thermal de Brogile wavelength \(\lambda_{th} = \frac{h}{\sqrt{2\pi mk_B T}}\)</li> <li>Time-scale limitations</li> <li>length-scale limitations</li> </ul> <h2 id="md-algorithm">MD Algorithm</h2> <p>The basic steps of MD algorithm is as following:</p> <ol> <li>Set the initial conditions: \(\vec r_i(t_0),\vec v_i(t_0,...)\)</li> <li>Update neighbour list</li> <li>Get forces \(\vec F_i(t)\)</li> <li>Solve equations of motion over \(\delta t\)</li> <li>Perform \(p,T\) control</li> <li> \[t=t+\delta t\] </li> <li>Calculate physical quantities</li> <li>Judge \(t=t_{\text{max}}\)?</li> </ol> <h3 id="setup">Setup</h3> <p>Before starting the simulation, several conditoins and parameters should be setup.</p> <h4 id="boundary-condition">Boundary Condition</h4> <p>In practice in most cases the atoms are arranged in an orthogonal simulation cell. There are several tpes of B.C.:</p> <ul> <li>Open boundary <ul> <li>for a molecule or nanocluster in vacuum</li> <li>not for a continuous medium</li> </ul> </li> <li>Fixed boundary <ul> <li>fixed boundary atoms</li> <li>completely unphysical</li> </ul> </li> <li>Periodic boundary <ul> <li>obtaining bulk properties</li> </ul> </li> </ul> <h4 id="initial-velocities">Initial Velocities</h4> <p>We use the <strong>Maxwell-Boltzmann distribution</strong> to set the cell temperature to a desired value.</p> <p>The probability of finding a particle with speed \(v\): \begin{equation} f(v)=\sqrt{(\frac{m}{2\pi k_B T})^3} 4\pi v^2 e^{-\frac{mv^2}{2k_B T}}. \end{equation} Then we can generate random initial atom velocities scaling \(T\) with equipartition theorem: \begin{equation} \frac{3}{2}k_B T=\frac{1}{2}mv^2. \end{equation}</p> <p><em>! Don’t forget to set the total momentum of the cell to zero !</em></p> <p>Initial Velocities:</p> <div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">subroutine</span><span class="w"> </span><span class="n">init</span><span class="w">
</span><span class="n">sumv</span><span class="o">=</span><span class="mi">0</span><span class="w">
</span><span class="n">sumv2</span><span class="o">=</span><span class="mi">0</span><span class="w">
</span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">npart</span><span class="w">
    </span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">lattice_pos</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w">
    </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">ranf</span><span class="p">()</span><span class="mf">-0.5</span><span class="p">)</span><span class="w">
    </span><span class="n">sumv</span><span class="o">=</span><span class="n">sumv</span><span class="o">+</span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w">
    </span><span class="n">sumv2</span><span class="o">=</span><span class="n">sumv2</span><span class="o">+</span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="w">
</span><span class="k">enddo</span><span class="w">
</span><span class="n">sumv</span><span class="o">=</span><span class="n">sumv</span><span class="p">/</span><span class="n">npart</span><span class="w">
</span><span class="n">sumv2</span><span class="o">=</span><span class="n">sumv2</span><span class="p">/</span><span class="n">npart</span><span class="w">
</span><span class="n">fs</span><span class="o">=</span><span class="nb">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">temp</span><span class="p">/</span><span class="n">sumv2</span><span class="p">)</span><span class="w">
</span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">npart</span><span class="w">
    </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="n">sumv</span><span class="p">)</span><span class="o">*</span><span class="n">fs</span><span class="w">
    </span><span class="n">xm</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="w">
</span><span class="k">enddo</span><span class="w">
</span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w">
</span></code></pre></div></div> <h4 id="choosing-md-time-step">Choosing MD Time Step</h4> <ul> <li>Too long \(\Deltat\): energy is not conserved</li> <li>\(\Delta r/\Delta t &gt; 1/20\) of the nearest atom distance</li> <li>In practice \(\Delta t \approx 4\text{fs}\)</li> <li>MD is limited to <strong>&lt;~100ns</strong> </li> </ul> <h4 id="constructing-neighbor">Constructing Neighbor</h4> <p>To save CPU time, we can set a cutoff distance \(r_{cut}\) as Calculating force at \(r_{ij}&gt;r_{cut}\) just wastes time. We can achieve this by <strong>constructing neighbor list and cell list.</strong></p> <h5 id="neighbor-list">Neighbor list</h5> <p>Looking for atoms within the cutoff distance at every step is quit time-consuming. However, since atoms move within a time step only \(&lt;0.2 \AA\), the local neighbors of a given atom remain the same for many time steps.</p> <h6 id="verlet-neighbor-list">Verlet Neighbor List</h6> <ul> <li>Containing all neighbor atoms within \(r_m\)</li> <li>If updating every \(N_m\) steps, the skin depth \(r_m-r_{cut} &gt; N_m\Delta t V_{typ}\), where \(V_{typ}\) is the typical speed of an atom. <h6 id="when-to-update">When to Update</h6> <p>A static value of \(N_m\) may lead to problems when there can be energetic process in the system so that \(v_j &gt;&gt; v_{typ}\).</p> </li> </ul> <p>A better way is to have a dynamic way of determing when to update the neighbor list:</p> <ol> <li>Keep track of the two largest atom displacements from the time when the neighbor list was updated the last time.</li> <li>Update the list when \(r_{\text{max},1}+r_{\text{max},2}&gt;r_m-r_c\).</li> </ol> </body></html>