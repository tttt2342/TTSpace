---
layout: post
title: Molecular Dynamics (MD)
date: 2025-6-1 15:00:00+0800
description: Introduction to molecular dynamics simulation 
tags: physics MD simulation
categories: ComputationalPhysics
related_posts: false
---

## Basic Idea
Molecular dynamics (MD) is a computer simulation technique that allows one to predict the time evolution of a system of interacting particles (atoms, molecules, granules, etc.).
First we have to specify:
- A set of **initial conditions** (positions & velocities)
- **Interaction potential** for deriving the forces among all the particles.

Second, the evolution in time can be followed by solving a  set of classical equations of motion for all particles in the system. Within the framework of classical mechanics, the equations are:
\begin{equation}
m_i\frac{d^2 \vec r_i}{dt^2}=\vec F_i
\end{equation}
for the $$i^{\text{th}}$$ particle.

If the particles of interest are atoms, the force acting on the $$i^{\text{th}}$$ atom at a given time can be obtained from the interatomic potential $$U$$ :
\begin{equation}
\vec F_i = -\vec \nabla_i U(\vec r_1,\vec r_2,\vec r_3,...,\vec r_{N_at})
\end{equation}

#### Advantages of MD
- The only input in the model - description of interatomic interaction
- No assumptions are made about the process
- Provides a detailed molecular/atomic-level information
- The main strengths of MD is the ability to study **fast non-equilibrium processes** with atomic-level resolution.

#### Limitations of Classic MD
- Usage of classical forces - ignoring quantum mechanical laws - de Brogile wavelength $$\lambda = \frac{h}{p}$$
- Quantum effects become important when $$T$$ is quite low - Thermal de Brogile wavelength $$\lambda_{th} = \frac{h}{\sqrt{2\pi mk_B T}}$$
- Time-scale limitations
- length-scale limitations

## MD Algorithm
The basic steps of MD algorithm is as following:
1. Set the initial conditions: $$\vec r_i(t_0),\vec v_i(t_0,...)$$
2. Update neighbour list
3. Get forces $$\vec F_i(t)$$
4. Solve equations of motion over $$\delta t$$
5. Perform $$p,T$$ control
6. Update time $$t=t+\delta t$$
7. Calculate physical quantities
8. Judge $$t=t_{\text{max}}$$?

### Setup
Before starting the simulation, several conditoins and parameters should be setup.
#### Boundary Condition
In practice in most cases the atoms are arranged in an orthogonal simulation cell. There are several tpes of B.C.:
- Open boundary
    * for a molecule or nanocluster in vacuum
    * not for a continuous medium
- Fixed boundary
    * fixed boundary atoms
    * completely unphysical
- Periodic boundary
    * obtaining bulk properties

#### Initial Velocities
We use the **Maxwell-Boltzmann distribution** to set the cell temperature to a desired value.

The probability of finding a particle with speed $$v$$:
\begin{equation}
f(v)=\sqrt{(\frac{m}{2\pi k_B T})^3} 4\pi v^2 e^{-\frac{mv^2}{2k_B T}}.
\end{equation}
Then we can generate random initial atom velocities scaling $$T$$ with equipartition theorem:
\begin{equation}
\frac{3}{2}k_B T=\frac{1}{2}mv^2.
\end{equation}

*! Don't forget to set the total momentum of the cell to zero !*

Initial Velocities:
```fortran
subroutine init
sumv=0
sumv2=0
do i=1,npart
    x(i)=lattice_pos(i)
    v(i)=(ranf()-0.5)
    sumv=sumv+v(i)
    sumv2=sumv2+v(i)**2
enddo
sumv=sumv/npart
sumv2=sumv2/npart
fs=sqrt(3*temp/sumv2)
do i=1,npart
    v(i)=(v(i)-sumv)*fs
    xm(i)=x(i)-v(i)*dt
enddo
return
end
```

#### Choosing MD Time Step
- Too long $$\Delta t$$: energy is not conserved
- $$\Delta r/\Delta t > 1/20$$ of the nearest atom distance
- In practice $$\Delta t \approx 4\text{fs}$$
- MD is limited to **<~100ns**

### Constructing Neighbor
To save CPU time, we can set a cutoff distance $$r_{cut}$$ as Calculating force at $$r_{ij}>r_{cut}$$ just wastes time. We can achieve this by **constructing neighbor list and cell list.**
#### Neighbor List
Looking for atoms within the cutoff distance at every step is quit time-consuming. However, since atoms move within a time step only $$<0.2 \dot{A}$$, the local neighbors of a given atom remain the same for many time steps.
##### Verlet Neighbor List
- Containing all neighbor atoms within $$r_m$$
- If updating every $$N_m$$ steps, the skin depth $$r_m-r_{cut} > N_m\Delta t V_{typ}$$, where $$V_{typ}$$ is the typical speed of an atom.
##### When to Update
A static value of $$N_m$$ may lead to problems when there can be energetic process in the system so that $$v_j >> v_{typ}$$.

A better way is to have a dynamic way of determing when to update the neighbor list:
1. Keep track of the two largest atom displacements from the time when the neighbor list was updated the last time.
2. Update the list when $$r_{\text{max},1}+r_{\text{max},2}>r_m-r_c$$.

#### Cell List
We can divide MD cell into smaller subcells $$n\times n\times n$$. The length of subcell $$l$$ is chosen s.t.
\begin{equation}
l=\frac{L}{n}>r_{cut}
\end{equation}

By this we can reduce the atom pairs from $$N(N-1)/2$$ to $$27N^2/n^3$$, reducing $$O(N^2)$$ to $$O(N)$$.

### Time Integration Algorithm
Among those methods to solve the second-order ODE, we choose Verlet Algorithm due to energy conservation.
#### Verlet Algorithm
We have the ieration equation:
\begin{equation}
\vec r (t+\Delta t)=2\vec r (t)-\vec r (t-\Delta t)+\vec a (t) \cdot (\Delta t)^2+o[(\Delta t)^4]
\end{equation}
where $$\vec a(t)=d^2\vec r /dt^2 = -\nabla V(\vec r(t))/m$$. (See [Page "ODE"](https://zhangty.com/blog/2025/ODE))
#### Velocity Verlet: ABetter Implementation
In Verlet Algorithm, the error associated to $$\vec v(t)$$ is of order $$o(\Delta t^2)$$ rather than $$o(\Delta t^4)$$. **Velocity Verlet** scheme, in which the positions, velocities and accelerations at time $$t+\Delta t$$ are obtained, is developed to overcome this difficulty.

The detailed steps are:
1. Compute **half next step velocity**: \vec v(t+\frac{\Delta t}{2})=\vec v(t)+\frac{1}{2}\vec a(t)\Delta t
2. Compute next position: $$\vec r(t+\Delta t) = \vec r (t)+\vec v(t)\cdot \Delta t +\frac{1}{2}\vec a(t)\cdot (\Delta t)^2$$
3. Compute next acceleration: $$\vec a(t+\Delta t)=-\frac{1}{m} \nabla V(\vec r(t+\Delta t))$$
4. Compute accurate next velocity: \vec v(t+\Delta t)=\vec v(t+\frac{\Delta t}{2})+\frac{1}{2}\vec a(t+\Delta t)\cdot \Delta t



